type TreeCreated @entity(immutable: true) {
  id: Bytes!
  treeId: Bytes! # bytes32
  treeAddress: Bytes! # address
  nftContractAddress: Bytes! # address
  creator: Bytes! # address
  rootContent: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NFTContractCreated @entity(immutable: true) {
  id: Bytes!
  nftContract: Bytes! # address
  creator: Bytes! # address
  treeId: Bytes! # bytes32
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NodeCreated @entity(immutable: true) {
  id: Bytes!
  nodeId: Bytes! # bytes32
  parentId: Bytes! # bytes32
  author: Bytes! # address
  timestamp: BigInt! # uint256
  treeAddress: Bytes! # address - the tree contract that emitted this event
  hasNFT: Boolean! # bool - whether this node has NFT/ERC20/ERC6551
  modelId: String # string - the model ID used to generate this node
  content: String # string - content for lightweight nodes (hasNFT: false)
  tokenId: BigInt # uint256 - NFT token ID (0 for lightweight nodes)
  tokenBoundAccount: Bytes # address - ERC6551 token bound account (null for lightweight nodes)
  nodeTokenContract: Bytes # address - ERC20 token contract (null for lightweight nodes)
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NodeUpdated @entity(immutable: true) {
  id: Bytes!
  nodeId: Bytes! # bytes32
  author: Bytes! # address
  treeAddress: Bytes! # address - the tree contract that emitted this event
  modelId: String # string - the model ID used to update this node
  content: String # string - updated content for lightweight nodes (hasNFT: false)
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type MetadataSet @entity(immutable: true) {
  id: Bytes!
  nodeId: Bytes! # bytes32
  key: String! # string
  value: String! # string
  treeAddress: Bytes! # address - the tree contract that emitted this event
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NodeNFTMinted @entity(immutable: true) {
  id: Bytes!
  tokenId: BigInt! # uint256
  nodeId: Bytes! # bytes32
  owner: Bytes! # address
  content: String! # string
  tokenBoundAccount: Bytes! # address
  nodeTokenContract: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NodeNFTContentUpdated @entity(immutable: true) {
  id: Bytes!
  tokenId: BigInt! # uint256
  nodeId: Bytes! # bytes32
  content: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NodeTokenCreated @entity(immutable: true) {
  id: Bytes!
  tokenId: BigInt! # uint256
  nodeTokenContract: Bytes! # address
  tokenBoundAccount: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type TokenBoundAccountCreated @entity(immutable: true) {
  id: Bytes!
  tokenId: BigInt! # uint256
  tokenBoundAccount: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type TokensMinted @entity(immutable: true) {
  id: Bytes!
  to: Bytes! # address
  amount: BigInt! # uint256
  reason: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type TokensBurned @entity(immutable: true) {
  id: Bytes!
  from: Bytes! # address
  amount: BigInt! # uint256
  reason: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NFTTransfer @entity(immutable: true) {
  id: Bytes!
  from: Bytes! # address
  to: Bytes! # address
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type TokenTransfer @entity(immutable: true) {
  id: Bytes!
  from: Bytes! # address
  to: Bytes! # address
  value: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}
